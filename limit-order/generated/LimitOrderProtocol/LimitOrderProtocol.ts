// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class NonceIncreased extends ethereum.Event {
  get params(): NonceIncreased__Params {
    return new NonceIncreased__Params(this);
  }
}

export class NonceIncreased__Params {
  _event: NonceIncreased;

  constructor(event: NonceIncreased) {
    this._event = event;
  }

  get maker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oldNonce(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get newNonce(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OrderCanceled extends ethereum.Event {
  get params(): OrderCanceled__Params {
    return new OrderCanceled__Params(this);
  }
}

export class OrderCanceled__Params {
  _event: OrderCanceled;

  constructor(event: OrderCanceled) {
    this._event = event;
  }

  get maker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get orderHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get remainingRaw(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OrderFilled extends ethereum.Event {
  get params(): OrderFilled__Params {
    return new OrderFilled__Params(this);
  }
}

export class OrderFilled__Params {
  _event: OrderFilled;

  constructor(event: OrderFilled) {
    this._event = event;
  }

  get taker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get orderHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get remaining(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get makingAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class OrderFilledRFQ extends ethereum.Event {
  get params(): OrderFilledRFQ__Params {
    return new OrderFilledRFQ__Params(this);
  }
}

export class OrderFilledRFQ__Params {
  _event: OrderFilledRFQ;

  constructor(event: OrderFilledRFQ) {
    this._event = event;
  }

  get taker(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get orderHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class UpdatedInteractionWhitelist extends ethereum.Event {
  get params(): UpdatedInteractionWhitelist__Params {
    return new UpdatedInteractionWhitelist__Params(this);
  }
}

export class UpdatedInteractionWhitelist__Params {
  _event: UpdatedInteractionWhitelist;

  constructor(event: UpdatedInteractionWhitelist) {
    this._event = event;
  }

  get _address(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get isWhitelist(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class LimitOrderProtocol__checkPredicateInputOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__fillBatchOrdersToResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillBatchOrdersToInputParamsStruct extends ethereum.Tuple {
  get orders(): Array<
    LimitOrderProtocol__fillBatchOrdersToInputParamsOrdersStruct
  > {
    return this[0].toTupleArray<
      LimitOrderProtocol__fillBatchOrdersToInputParamsOrdersStruct
    >();
  }

  get signatures(): Array<Bytes> {
    return this[1].toBytesArray();
  }

  get takingAmount(): BigInt {
    return this[2].toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this[3].toBigInt();
  }

  get target(): Address {
    return this[4].toAddress();
  }
}

export class LimitOrderProtocol__fillBatchOrdersToInputParamsOrdersStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__fillOrderResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderInputOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__fillOrderRFQResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderRFQInputOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class LimitOrderProtocol__fillOrderRFQToResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderRFQToInputOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class LimitOrderProtocol__fillOrderRFQToWithPermitResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderRFQToWithPermitInputOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class LimitOrderProtocol__fillOrderToResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderToInputParamsStruct extends ethereum.Tuple {
  get order(): LimitOrderProtocol__fillOrderToInputParamsOrderStruct {
    return changetype<LimitOrderProtocol__fillOrderToInputParamsOrderStruct>(
      this[0].toTuple()
    );
  }

  get signature(): Bytes {
    return this[1].toBytes();
  }

  get makingAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[3].toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this[4].toBigInt();
  }

  get target(): Address {
    return this[5].toAddress();
  }

  get callbackData(): Bytes {
    return this[6].toBytes();
  }
}

export class LimitOrderProtocol__fillOrderToInputParamsOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__fillOrderToWithPermitResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class LimitOrderProtocol__fillOrderToWithPermitInputOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__hashOrderInputOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class LimitOrderProtocol__hashOrderRFQInputOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class LimitOrderProtocol extends ethereum.SmartContract {
  static bind(address: Address): LimitOrderProtocol {
    return new LimitOrderProtocol("LimitOrderProtocol", address);
  }

  DOMAIN_SEPARATOR(): Bytes {
    let result = super.call(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_DOMAIN_SEPARATOR(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  LIMIT_ORDER_RFQ_TYPEHASH(): Bytes {
    let result = super.call(
      "LIMIT_ORDER_RFQ_TYPEHASH",
      "LIMIT_ORDER_RFQ_TYPEHASH():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_LIMIT_ORDER_RFQ_TYPEHASH(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "LIMIT_ORDER_RFQ_TYPEHASH",
      "LIMIT_ORDER_RFQ_TYPEHASH():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  LIMIT_ORDER_TYPEHASH(): Bytes {
    let result = super.call(
      "LIMIT_ORDER_TYPEHASH",
      "LIMIT_ORDER_TYPEHASH():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_LIMIT_ORDER_TYPEHASH(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "LIMIT_ORDER_TYPEHASH",
      "LIMIT_ORDER_TYPEHASH():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  and(targets: Array<Address>, data: Array<Bytes>): boolean {
    let result = super.call("and", "and(address[],bytes[]):(bool)", [
      ethereum.Value.fromAddressArray(targets),
      ethereum.Value.fromBytesArray(data)
    ]);

    return result[0].toBoolean();
  }

  try_and(
    targets: Array<Address>,
    data: Array<Bytes>
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("and", "and(address[],bytes[]):(bool)", [
      ethereum.Value.fromAddressArray(targets),
      ethereum.Value.fromBytesArray(data)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  arbitraryStaticCall(target: Address, data: Bytes): BigInt {
    let result = super.call(
      "arbitraryStaticCall",
      "arbitraryStaticCall(address,bytes):(uint256)",
      [ethereum.Value.fromAddress(target), ethereum.Value.fromBytes(data)]
    );

    return result[0].toBigInt();
  }

  try_arbitraryStaticCall(
    target: Address,
    data: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "arbitraryStaticCall",
      "arbitraryStaticCall(address,bytes):(uint256)",
      [ethereum.Value.fromAddress(target), ethereum.Value.fromBytes(data)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  checkPredicate(
    order: LimitOrderProtocol__checkPredicateInputOrderStruct
  ): boolean {
    let result = super.call(
      "checkPredicate",
      "checkPredicate((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)):(bool)",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toBoolean();
  }

  try_checkPredicate(
    order: LimitOrderProtocol__checkPredicateInputOrderStruct
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "checkPredicate",
      "checkPredicate((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)):(bool)",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  doublePrice(
    oracle1: Address,
    oracle2: Address,
    spread: BigInt,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "doublePrice",
      "doublePrice(address,address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracle1),
        ethereum.Value.fromAddress(oracle2),
        ethereum.Value.fromUnsignedBigInt(spread),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_doublePrice(
    oracle1: Address,
    oracle2: Address,
    spread: BigInt,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "doublePrice",
      "doublePrice(address,address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracle1),
        ethereum.Value.fromAddress(oracle2),
        ethereum.Value.fromUnsignedBigInt(spread),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  eq(value: BigInt, target: Address, data: Bytes): boolean {
    let result = super.call("eq", "eq(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);

    return result[0].toBoolean();
  }

  try_eq(
    value: BigInt,
    target: Address,
    data: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("eq", "eq(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  fillBatchOrdersTo(
    params: LimitOrderProtocol__fillBatchOrdersToInputParamsStruct
  ): LimitOrderProtocol__fillBatchOrdersToResult {
    let result = super.call(
      "fillBatchOrdersTo",
      "fillBatchOrdersTo(((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)[],bytes[],uint256,uint256,address)):(uint256,uint256)",
      [ethereum.Value.fromTuple(params)]
    );

    return new LimitOrderProtocol__fillBatchOrdersToResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillBatchOrdersTo(
    params: LimitOrderProtocol__fillBatchOrdersToInputParamsStruct
  ): ethereum.CallResult<LimitOrderProtocol__fillBatchOrdersToResult> {
    let result = super.tryCall(
      "fillBatchOrdersTo",
      "fillBatchOrdersTo(((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)[],bytes[],uint256,uint256,address)):(uint256,uint256)",
      [ethereum.Value.fromTuple(params)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillBatchOrdersToResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrder(
    order: LimitOrderProtocol__fillOrderInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    thresholdAmount: BigInt,
    callbackData: Bytes
  ): LimitOrderProtocol__fillOrderResult {
    let result = super.call(
      "fillOrder",
      "fillOrder((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromUnsignedBigInt(thresholdAmount),
        ethereum.Value.fromBytes(callbackData)
      ]
    );

    return new LimitOrderProtocol__fillOrderResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrder(
    order: LimitOrderProtocol__fillOrderInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    thresholdAmount: BigInt,
    callbackData: Bytes
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderResult> {
    let result = super.tryCall(
      "fillOrder",
      "fillOrder((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromUnsignedBigInt(thresholdAmount),
        ethereum.Value.fromBytes(callbackData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrderRFQ(
    order: LimitOrderProtocol__fillOrderRFQInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt
  ): LimitOrderProtocol__fillOrderRFQResult {
    let result = super.call(
      "fillOrderRFQ",
      "fillOrderRFQ((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount)
      ]
    );

    return new LimitOrderProtocol__fillOrderRFQResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrderRFQ(
    order: LimitOrderProtocol__fillOrderRFQInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderRFQResult> {
    let result = super.tryCall(
      "fillOrderRFQ",
      "fillOrderRFQ((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderRFQResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrderRFQTo(
    order: LimitOrderProtocol__fillOrderRFQToInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    target: Address
  ): LimitOrderProtocol__fillOrderRFQToResult {
    let result = super.call(
      "fillOrderRFQTo",
      "fillOrderRFQTo((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256,address):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromAddress(target)
      ]
    );

    return new LimitOrderProtocol__fillOrderRFQToResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrderRFQTo(
    order: LimitOrderProtocol__fillOrderRFQToInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    target: Address
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderRFQToResult> {
    let result = super.tryCall(
      "fillOrderRFQTo",
      "fillOrderRFQTo((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256,address):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromAddress(target)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderRFQToResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrderRFQToWithPermit(
    order: LimitOrderProtocol__fillOrderRFQToWithPermitInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    target: Address,
    permit: Bytes
  ): LimitOrderProtocol__fillOrderRFQToWithPermitResult {
    let result = super.call(
      "fillOrderRFQToWithPermit",
      "fillOrderRFQToWithPermit((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256,address,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromAddress(target),
        ethereum.Value.fromBytes(permit)
      ]
    );

    return new LimitOrderProtocol__fillOrderRFQToWithPermitResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrderRFQToWithPermit(
    order: LimitOrderProtocol__fillOrderRFQToWithPermitInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    target: Address,
    permit: Bytes
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderRFQToWithPermitResult> {
    let result = super.tryCall(
      "fillOrderRFQToWithPermit",
      "fillOrderRFQToWithPermit((uint256,address,address,address,address,uint256,uint256,uint256),bytes,uint256,uint256,address,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromAddress(target),
        ethereum.Value.fromBytes(permit)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderRFQToWithPermitResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrderTo(
    params: LimitOrderProtocol__fillOrderToInputParamsStruct,
    isForcedFill: boolean
  ): LimitOrderProtocol__fillOrderToResult {
    let result = super.call(
      "fillOrderTo",
      "fillOrderTo(((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,address,bytes),bool):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(params),
        ethereum.Value.fromBoolean(isForcedFill)
      ]
    );

    return new LimitOrderProtocol__fillOrderToResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrderTo(
    params: LimitOrderProtocol__fillOrderToInputParamsStruct,
    isForcedFill: boolean
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderToResult> {
    let result = super.tryCall(
      "fillOrderTo",
      "fillOrderTo(((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,address,bytes),bool):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(params),
        ethereum.Value.fromBoolean(isForcedFill)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderToResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  fillOrderToWithPermit(
    order: LimitOrderProtocol__fillOrderToWithPermitInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    thresholdAmount: BigInt,
    target: Address,
    permit: Bytes,
    callbackData: Bytes
  ): LimitOrderProtocol__fillOrderToWithPermitResult {
    let result = super.call(
      "fillOrderToWithPermit",
      "fillOrderToWithPermit((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,address,bytes,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromUnsignedBigInt(thresholdAmount),
        ethereum.Value.fromAddress(target),
        ethereum.Value.fromBytes(permit),
        ethereum.Value.fromBytes(callbackData)
      ]
    );

    return new LimitOrderProtocol__fillOrderToWithPermitResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_fillOrderToWithPermit(
    order: LimitOrderProtocol__fillOrderToWithPermitInputOrderStruct,
    signature: Bytes,
    makingAmount: BigInt,
    takingAmount: BigInt,
    thresholdAmount: BigInt,
    target: Address,
    permit: Bytes,
    callbackData: Bytes
  ): ethereum.CallResult<LimitOrderProtocol__fillOrderToWithPermitResult> {
    let result = super.tryCall(
      "fillOrderToWithPermit",
      "fillOrderToWithPermit((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,address,bytes,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromTuple(order),
        ethereum.Value.fromBytes(signature),
        ethereum.Value.fromUnsignedBigInt(makingAmount),
        ethereum.Value.fromUnsignedBigInt(takingAmount),
        ethereum.Value.fromUnsignedBigInt(thresholdAmount),
        ethereum.Value.fromAddress(target),
        ethereum.Value.fromBytes(permit),
        ethereum.Value.fromBytes(callbackData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LimitOrderProtocol__fillOrderToWithPermitResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getMakerAmount(
    orderMakerAmount: BigInt,
    orderTakerAmount: BigInt,
    swapTakerAmount: BigInt
  ): BigInt {
    let result = super.call(
      "getMakerAmount",
      "getMakerAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(orderMakerAmount),
        ethereum.Value.fromUnsignedBigInt(orderTakerAmount),
        ethereum.Value.fromUnsignedBigInt(swapTakerAmount)
      ]
    );

    return result[0].toBigInt();
  }

  try_getMakerAmount(
    orderMakerAmount: BigInt,
    orderTakerAmount: BigInt,
    swapTakerAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMakerAmount",
      "getMakerAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(orderMakerAmount),
        ethereum.Value.fromUnsignedBigInt(orderTakerAmount),
        ethereum.Value.fromUnsignedBigInt(swapTakerAmount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTakerAmount(
    orderMakerAmount: BigInt,
    orderTakerAmount: BigInt,
    swapMakerAmount: BigInt
  ): BigInt {
    let result = super.call(
      "getTakerAmount",
      "getTakerAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(orderMakerAmount),
        ethereum.Value.fromUnsignedBigInt(orderTakerAmount),
        ethereum.Value.fromUnsignedBigInt(swapMakerAmount)
      ]
    );

    return result[0].toBigInt();
  }

  try_getTakerAmount(
    orderMakerAmount: BigInt,
    orderTakerAmount: BigInt,
    swapMakerAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTakerAmount",
      "getTakerAmount(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(orderMakerAmount),
        ethereum.Value.fromUnsignedBigInt(orderTakerAmount),
        ethereum.Value.fromUnsignedBigInt(swapMakerAmount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  gt(value: BigInt, target: Address, data: Bytes): boolean {
    let result = super.call("gt", "gt(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);

    return result[0].toBoolean();
  }

  try_gt(
    value: BigInt,
    target: Address,
    data: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("gt", "gt(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hashOrder(order: LimitOrderProtocol__hashOrderInputOrderStruct): Bytes {
    let result = super.call(
      "hashOrder",
      "hashOrder((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toBytes();
  }

  try_hashOrder(
    order: LimitOrderProtocol__hashOrderInputOrderStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "hashOrder",
      "hashOrder((uint256,address,address,address,address,address,uint256,uint256,address,uint256,bytes,bytes,bytes,bytes,bytes,bytes,bytes)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  hashOrderRFQ(order: LimitOrderProtocol__hashOrderRFQInputOrderStruct): Bytes {
    let result = super.call(
      "hashOrderRFQ",
      "hashOrderRFQ((uint256,address,address,address,address,uint256,uint256,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );

    return result[0].toBytes();
  }

  try_hashOrderRFQ(
    order: LimitOrderProtocol__hashOrderRFQInputOrderStruct
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "hashOrderRFQ",
      "hashOrderRFQ((uint256,address,address,address,address,uint256,uint256,uint256)):(bytes32)",
      [ethereum.Value.fromTuple(order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  invalidatorForOrderRFQ(maker: Address, slot: BigInt): BigInt {
    let result = super.call(
      "invalidatorForOrderRFQ",
      "invalidatorForOrderRFQ(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(maker),
        ethereum.Value.fromUnsignedBigInt(slot)
      ]
    );

    return result[0].toBigInt();
  }

  try_invalidatorForOrderRFQ(
    maker: Address,
    slot: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "invalidatorForOrderRFQ",
      "invalidatorForOrderRFQ(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(maker),
        ethereum.Value.fromUnsignedBigInt(slot)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lt(value: BigInt, target: Address, data: Bytes): boolean {
    let result = super.call("lt", "lt(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);

    return result[0].toBoolean();
  }

  try_lt(
    value: BigInt,
    target: Address,
    data: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("lt", "lt(uint256,address,bytes):(bool)", [
      ethereum.Value.fromUnsignedBigInt(value),
      ethereum.Value.fromAddress(target),
      ethereum.Value.fromBytes(data)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nonce(param0: Address): BigInt {
    let result = super.call("nonce", "nonce(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_nonce(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nonce", "nonce(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nonceEquals(makerAddress: Address, makerNonce: BigInt): boolean {
    let result = super.call(
      "nonceEquals",
      "nonceEquals(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(makerAddress),
        ethereum.Value.fromUnsignedBigInt(makerNonce)
      ]
    );

    return result[0].toBoolean();
  }

  try_nonceEquals(
    makerAddress: Address,
    makerNonce: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "nonceEquals",
      "nonceEquals(address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(makerAddress),
        ethereum.Value.fromUnsignedBigInt(makerNonce)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  or(targets: Array<Address>, data: Array<Bytes>): boolean {
    let result = super.call("or", "or(address[],bytes[]):(bool)", [
      ethereum.Value.fromAddressArray(targets),
      ethereum.Value.fromBytesArray(data)
    ]);

    return result[0].toBoolean();
  }

  try_or(
    targets: Array<Address>,
    data: Array<Bytes>
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("or", "or(address[],bytes[]):(bool)", [
      ethereum.Value.fromAddressArray(targets),
      ethereum.Value.fromBytesArray(data)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  remaining(orderHash: Bytes): BigInt {
    let result = super.call("remaining", "remaining(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(orderHash)
    ]);

    return result[0].toBigInt();
  }

  try_remaining(orderHash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall("remaining", "remaining(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(orderHash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  remainingRaw(orderHash: Bytes): BigInt {
    let result = super.call("remainingRaw", "remainingRaw(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(orderHash)
    ]);

    return result[0].toBigInt();
  }

  try_remainingRaw(orderHash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "remainingRaw",
      "remainingRaw(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(orderHash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  remainingsRaw(orderHashes: Array<Bytes>): Array<BigInt> {
    let result = super.call(
      "remainingsRaw",
      "remainingsRaw(bytes32[]):(uint256[])",
      [ethereum.Value.fromFixedBytesArray(orderHashes)]
    );

    return result[0].toBigIntArray();
  }

  try_remainingsRaw(
    orderHashes: Array<Bytes>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "remainingsRaw",
      "remainingsRaw(bytes32[]):(uint256[])",
      [ethereum.Value.fromFixedBytesArray(orderHashes)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  singlePrice(
    oracle: Address,
    inverseAndSpread: BigInt,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "singlePrice",
      "singlePrice(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracle),
        ethereum.Value.fromUnsignedBigInt(inverseAndSpread),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_singlePrice(
    oracle: Address,
    inverseAndSpread: BigInt,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "singlePrice",
      "singlePrice(address,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracle),
        ethereum.Value.fromUnsignedBigInt(inverseAndSpread),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  timestampBelow(time: BigInt): boolean {
    let result = super.call(
      "timestampBelow",
      "timestampBelow(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(time)]
    );

    return result[0].toBoolean();
  }

  try_timestampBelow(time: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "timestampBelow",
      "timestampBelow(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(time)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class AdvanceNonceCall extends ethereum.Call {
  get inputs(): AdvanceNonceCall__Inputs {
    return new AdvanceNonceCall__Inputs(this);
  }

  get outputs(): AdvanceNonceCall__Outputs {
    return new AdvanceNonceCall__Outputs(this);
  }
}

export class AdvanceNonceCall__Inputs {
  _call: AdvanceNonceCall;

  constructor(call: AdvanceNonceCall) {
    this._call = call;
  }

  get amount(): i32 {
    return this._call.inputValues[0].value.toI32();
  }
}

export class AdvanceNonceCall__Outputs {
  _call: AdvanceNonceCall;

  constructor(call: AdvanceNonceCall) {
    this._call = call;
  }
}

export class CancelBatchOrdersCall extends ethereum.Call {
  get inputs(): CancelBatchOrdersCall__Inputs {
    return new CancelBatchOrdersCall__Inputs(this);
  }

  get outputs(): CancelBatchOrdersCall__Outputs {
    return new CancelBatchOrdersCall__Outputs(this);
  }
}

export class CancelBatchOrdersCall__Inputs {
  _call: CancelBatchOrdersCall;

  constructor(call: CancelBatchOrdersCall) {
    this._call = call;
  }

  get orders(): Array<CancelBatchOrdersCallOrdersStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      CancelBatchOrdersCallOrdersStruct
    >();
  }
}

export class CancelBatchOrdersCall__Outputs {
  _call: CancelBatchOrdersCall;

  constructor(call: CancelBatchOrdersCall) {
    this._call = call;
  }
}

export class CancelBatchOrdersCallOrdersStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class CancelOrderCall extends ethereum.Call {
  get inputs(): CancelOrderCall__Inputs {
    return new CancelOrderCall__Inputs(this);
  }

  get outputs(): CancelOrderCall__Outputs {
    return new CancelOrderCall__Outputs(this);
  }
}

export class CancelOrderCall__Inputs {
  _call: CancelOrderCall;

  constructor(call: CancelOrderCall) {
    this._call = call;
  }

  get order(): CancelOrderCallOrderStruct {
    return changetype<CancelOrderCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class CancelOrderCall__Outputs {
  _call: CancelOrderCall;

  constructor(call: CancelOrderCall) {
    this._call = call;
  }
}

export class CancelOrderCallOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class CancelOrderRFQCall extends ethereum.Call {
  get inputs(): CancelOrderRFQCall__Inputs {
    return new CancelOrderRFQCall__Inputs(this);
  }

  get outputs(): CancelOrderRFQCall__Outputs {
    return new CancelOrderRFQCall__Outputs(this);
  }
}

export class CancelOrderRFQCall__Inputs {
  _call: CancelOrderRFQCall;

  constructor(call: CancelOrderRFQCall) {
    this._call = call;
  }

  get orderInfo(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CancelOrderRFQCall__Outputs {
  _call: CancelOrderRFQCall;

  constructor(call: CancelOrderRFQCall) {
    this._call = call;
  }
}

export class FillBatchOrdersToCall extends ethereum.Call {
  get inputs(): FillBatchOrdersToCall__Inputs {
    return new FillBatchOrdersToCall__Inputs(this);
  }

  get outputs(): FillBatchOrdersToCall__Outputs {
    return new FillBatchOrdersToCall__Outputs(this);
  }
}

export class FillBatchOrdersToCall__Inputs {
  _call: FillBatchOrdersToCall;

  constructor(call: FillBatchOrdersToCall) {
    this._call = call;
  }

  get params(): FillBatchOrdersToCallParamsStruct {
    return changetype<FillBatchOrdersToCallParamsStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class FillBatchOrdersToCall__Outputs {
  _call: FillBatchOrdersToCall;

  constructor(call: FillBatchOrdersToCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillBatchOrdersToCallParamsStruct extends ethereum.Tuple {
  get orders(): Array<FillBatchOrdersToCallParamsOrdersStruct> {
    return this[0].toTupleArray<FillBatchOrdersToCallParamsOrdersStruct>();
  }

  get signatures(): Array<Bytes> {
    return this[1].toBytesArray();
  }

  get takingAmount(): BigInt {
    return this[2].toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this[3].toBigInt();
  }

  get target(): Address {
    return this[4].toAddress();
  }
}

export class FillBatchOrdersToCallParamsOrdersStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class FillOrderCall extends ethereum.Call {
  get inputs(): FillOrderCall__Inputs {
    return new FillOrderCall__Inputs(this);
  }

  get outputs(): FillOrderCall__Outputs {
    return new FillOrderCall__Outputs(this);
  }
}

export class FillOrderCall__Inputs {
  _call: FillOrderCall;

  constructor(call: FillOrderCall) {
    this._call = call;
  }

  get order(): FillOrderCallOrderStruct {
    return changetype<FillOrderCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get callbackData(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class FillOrderCall__Outputs {
  _call: FillOrderCall;

  constructor(call: FillOrderCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderCallOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class FillOrderRFQCall extends ethereum.Call {
  get inputs(): FillOrderRFQCall__Inputs {
    return new FillOrderRFQCall__Inputs(this);
  }

  get outputs(): FillOrderRFQCall__Outputs {
    return new FillOrderRFQCall__Outputs(this);
  }
}

export class FillOrderRFQCall__Inputs {
  _call: FillOrderRFQCall;

  constructor(call: FillOrderRFQCall) {
    this._call = call;
  }

  get order(): FillOrderRFQCallOrderStruct {
    return changetype<FillOrderRFQCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class FillOrderRFQCall__Outputs {
  _call: FillOrderRFQCall;

  constructor(call: FillOrderRFQCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderRFQCallOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class FillOrderRFQToCall extends ethereum.Call {
  get inputs(): FillOrderRFQToCall__Inputs {
    return new FillOrderRFQToCall__Inputs(this);
  }

  get outputs(): FillOrderRFQToCall__Outputs {
    return new FillOrderRFQToCall__Outputs(this);
  }
}

export class FillOrderRFQToCall__Inputs {
  _call: FillOrderRFQToCall;

  constructor(call: FillOrderRFQToCall) {
    this._call = call;
  }

  get order(): FillOrderRFQToCallOrderStruct {
    return changetype<FillOrderRFQToCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get target(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class FillOrderRFQToCall__Outputs {
  _call: FillOrderRFQToCall;

  constructor(call: FillOrderRFQToCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderRFQToCallOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class FillOrderRFQToWithPermitCall extends ethereum.Call {
  get inputs(): FillOrderRFQToWithPermitCall__Inputs {
    return new FillOrderRFQToWithPermitCall__Inputs(this);
  }

  get outputs(): FillOrderRFQToWithPermitCall__Outputs {
    return new FillOrderRFQToWithPermitCall__Outputs(this);
  }
}

export class FillOrderRFQToWithPermitCall__Inputs {
  _call: FillOrderRFQToWithPermitCall;

  constructor(call: FillOrderRFQToWithPermitCall) {
    this._call = call;
  }

  get order(): FillOrderRFQToWithPermitCallOrderStruct {
    return changetype<FillOrderRFQToWithPermitCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get target(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get permit(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class FillOrderRFQToWithPermitCall__Outputs {
  _call: FillOrderRFQToWithPermitCall;

  constructor(call: FillOrderRFQToWithPermitCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderRFQToWithPermitCallOrderStruct extends ethereum.Tuple {
  get info(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get allowedSender(): Address {
    return this[4].toAddress();
  }

  get makingAmount(): BigInt {
    return this[5].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get makingAmountThreshold(): BigInt {
    return this[7].toBigInt();
  }
}

export class FillOrderToCall extends ethereum.Call {
  get inputs(): FillOrderToCall__Inputs {
    return new FillOrderToCall__Inputs(this);
  }

  get outputs(): FillOrderToCall__Outputs {
    return new FillOrderToCall__Outputs(this);
  }
}

export class FillOrderToCall__Inputs {
  _call: FillOrderToCall;

  constructor(call: FillOrderToCall) {
    this._call = call;
  }

  get params(): FillOrderToCallParamsStruct {
    return changetype<FillOrderToCallParamsStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get isForcedFill(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class FillOrderToCall__Outputs {
  _call: FillOrderToCall;

  constructor(call: FillOrderToCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderToCallParamsStruct extends ethereum.Tuple {
  get order(): FillOrderToCallParamsOrderStruct {
    return changetype<FillOrderToCallParamsOrderStruct>(this[0].toTuple());
  }

  get signature(): Bytes {
    return this[1].toBytes();
  }

  get makingAmount(): BigInt {
    return this[2].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[3].toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this[4].toBigInt();
  }

  get target(): Address {
    return this[5].toAddress();
  }

  get callbackData(): Bytes {
    return this[6].toBytes();
  }
}

export class FillOrderToCallParamsOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class FillOrderToWithPermitCall extends ethereum.Call {
  get inputs(): FillOrderToWithPermitCall__Inputs {
    return new FillOrderToWithPermitCall__Inputs(this);
  }

  get outputs(): FillOrderToWithPermitCall__Outputs {
    return new FillOrderToWithPermitCall__Outputs(this);
  }
}

export class FillOrderToWithPermitCall__Inputs {
  _call: FillOrderToWithPermitCall;

  constructor(call: FillOrderToWithPermitCall) {
    this._call = call;
  }

  get order(): FillOrderToWithPermitCallOrderStruct {
    return changetype<FillOrderToWithPermitCallOrderStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get signature(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get makingAmount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get takingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get thresholdAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get target(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get permit(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }

  get callbackData(): Bytes {
    return this._call.inputValues[7].value.toBytes();
  }
}

export class FillOrderToWithPermitCall__Outputs {
  _call: FillOrderToWithPermitCall;

  constructor(call: FillOrderToWithPermitCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FillOrderToWithPermitCallOrderStruct extends ethereum.Tuple {
  get salt(): BigInt {
    return this[0].toBigInt();
  }

  get makerAsset(): Address {
    return this[1].toAddress();
  }

  get takerAsset(): Address {
    return this[2].toAddress();
  }

  get maker(): Address {
    return this[3].toAddress();
  }

  get receiver(): Address {
    return this[4].toAddress();
  }

  get allowedSender(): Address {
    return this[5].toAddress();
  }

  get makingAmount(): BigInt {
    return this[6].toBigInt();
  }

  get takingAmount(): BigInt {
    return this[7].toBigInt();
  }

  get feeRecipient(): Address {
    return this[8].toAddress();
  }

  get takerTokenFeeAmount(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get getMakerAmount(): Bytes {
    return this[12].toBytes();
  }

  get getTakerAmount(): Bytes {
    return this[13].toBytes();
  }

  get predicate(): Bytes {
    return this[14].toBytes();
  }

  get permit(): Bytes {
    return this[15].toBytes();
  }

  get interaction(): Bytes {
    return this[16].toBytes();
  }
}

export class IncreaseNonceCall extends ethereum.Call {
  get inputs(): IncreaseNonceCall__Inputs {
    return new IncreaseNonceCall__Inputs(this);
  }

  get outputs(): IncreaseNonceCall__Outputs {
    return new IncreaseNonceCall__Outputs(this);
  }
}

export class IncreaseNonceCall__Inputs {
  _call: IncreaseNonceCall;

  constructor(call: IncreaseNonceCall) {
    this._call = call;
  }
}

export class IncreaseNonceCall__Outputs {
  _call: IncreaseNonceCall;

  constructor(call: IncreaseNonceCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SimulateCallsCall extends ethereum.Call {
  get inputs(): SimulateCallsCall__Inputs {
    return new SimulateCallsCall__Inputs(this);
  }

  get outputs(): SimulateCallsCall__Outputs {
    return new SimulateCallsCall__Outputs(this);
  }
}

export class SimulateCallsCall__Inputs {
  _call: SimulateCallsCall;

  constructor(call: SimulateCallsCall) {
    this._call = call;
  }

  get targets(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get data(): Array<Bytes> {
    return this._call.inputValues[1].value.toBytesArray();
  }
}

export class SimulateCallsCall__Outputs {
  _call: SimulateCallsCall;

  constructor(call: SimulateCallsCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UpdateInteractionWhitelistCall extends ethereum.Call {
  get inputs(): UpdateInteractionWhitelistCall__Inputs {
    return new UpdateInteractionWhitelistCall__Inputs(this);
  }

  get outputs(): UpdateInteractionWhitelistCall__Outputs {
    return new UpdateInteractionWhitelistCall__Outputs(this);
  }
}

export class UpdateInteractionWhitelistCall__Inputs {
  _call: UpdateInteractionWhitelistCall;

  constructor(call: UpdateInteractionWhitelistCall) {
    this._call = call;
  }

  get _address(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get isWhitelist(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class UpdateInteractionWhitelistCall__Outputs {
  _call: UpdateInteractionWhitelistCall;

  constructor(call: UpdateInteractionWhitelistCall) {
    this._call = call;
  }
}
